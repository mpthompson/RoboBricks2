   1               	# 1 "../avrx/serialio.S"
   2               	# 1 "<built-in>"
   1               	/*
   0               	
   0               	
   2               	File:   Serialio.asm
   3               	
   4               	Copyright ©1998 - 2002 Larry Barello
   5               	
   6               	This library is free software; you can redistribute it and/or
   7               	modify it under the terms of the GNU Library General Public
   8               	License as published by the Free Software Foundation; either
   9               	version 2 of the License, or (at your option) any later version.
  10               	
  11               	This library is distributed in the hope that it will be useful,
  12               	but WITHOUT ANY WARRANTY; without even the implied warranty of
  13               	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14               	Library General Public License for more details.
  15               	
  16               	You should have received a copy of the GNU Library General Public
  17               	License along with this library; if not, write to the
  18               	Free Software Foundation, Inc., 59 Temple Place - Suite 330,
  19               	Boston, MA  02111-1307, USA.
  20               	
  21               	http://www.gnu.org/copyleft/lgpl.html
  22               	
  23               	
  24               	Revision:
  25               	20050918 - This file removed from avrx library (it is too confusing, to limited).
  26               	
  27               	20020907 - Delete all header file references.  Fix this in "avrx.inc"
  28               		 - Added _SFR_IO_ADDR() macro to all i/o access (3.2 compat)
  29               	8/27/02	- Changed "io.h" to "io-avr.h" as the former includes some C only header files.
  30               	
  31               	6/4/02	- Changed Rx and UDRE interrupt routines to use the #defined
  32               		names to conform with the new GCC interrupt vector table handling
  33               		mechanism (this breaks IAR support in general for the mega stuff).
  34               		- fixed alias support for UCR and USR for bigger mega chips.
  35               	
  36               	6/13/01 - Added aliases for UCR and USR as the mega series
  37               	        changed the names for some reason...
  38               	
  39               	1/31/01 - Changed InitSerialIO parameter register to conform to new
  40               	        GCC calling conventions (R25 -> R24)
  41               	
  42               	5/30/02 - Fixed re-defines of various USART registers.  What a mess.  Added
  43               		code to initialize mega128 upper baud rate register.
  44               	
  45               	NOTE: This code is might be C compatible. I have not tested it or gone over it
  46               	carefully to insure compatibility.   In general the Monitor and the
  47               	serial routines should run in their own task space and not be called by
  48               	any C code.
  49               	
  50               	*/
  51               	#include        "avrx.inc"
   1               	#ifndef __AVRXINC
   2               	#define __AVRXINC
   3               	#include "avrx-ctoasm.inc"
   1               	/*
   2               	 C to ASM
   3               	
   4               	*/
   4               	/*
   5               	
   6               	Copyright ©1998-2002 Larry Barello
   7               	
   8               	Author: Larry Barello
   9               	        larry@barello.net
  10               	
  11               	20020907 - Added _IOMACRO_H_ definition to prevent older GCC io.h files
  12               		   from including C only header information
  13               	
  14               		 - Added #defines for _SFR_IO_ADDR() macro to make it a NOP for
  15               		   pre GCC 3.2 compilers and for IAR (I wonder what they do for
  16               		   extended I/O access?)
  17               	
  18               		   THIS works because avrx.inc loads "io.h" which loads "sfr-defs.h"
  19               		   which defines _SFR_IO_ADDR() macro on the 3.2 compiler.
  20               	*/
  21               	// Define _IOMACROS_H_ to prevent GCC 3.02 io.h from including this
  22               	// C only file when using io.h for assembly code.  io.h called within
  23               	// avrx-io.h
  24               	#define _IOMACROS_H_
  25               	#include "avrx-io.h"
   1               	// 20021123 - Changed <io.h> to <avr/io.h> for 3.3 compiler
   2               	
   3               	#if !defined(__IAR_SYSTEMS_ICC__) && !defined(__IAR_SYSTEMS_ASM__)
   4               	#include <avr/io.h>
   1               	/* Copyright (c) 2002,2003,2005,2006, Marek Michalkiewicz, Joerg Wunsch
   2               	   All rights reserved.
   3               	
   4               	   Redistribution and use in source and binary forms, with or without
   5               	   modification, are permitted provided that the following conditions are met:
   6               	
   7               	   * Redistributions of source code must retain the above copyright
   8               	     notice, this list of conditions and the following disclaimer.
   9               	
  10               	   * Redistributions in binary form must reproduce the above copyright
  11               	     notice, this list of conditions and the following disclaimer in
  12               	     the documentation and/or other materials provided with the
  13               	     distribution.
  14               	
  15               	   * Neither the name of the copyright holders nor the names of
  16               	     contributors may be used to endorse or promote products derived
  17               	     from this software without specific prior written permission.
  18               	
  19               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29               	  POSSIBILITY OF SUCH DAMAGE. */
  30               	
  31               	/* $Id: io.h,v 1.24.2.9 2006/09/13 20:41:41 arcanum Exp $ */
  32               	
  33               	/** \defgroup avr_io <avr/io.h>: AVR device-specific IO definitions
  34               	    \code #include <avr/io.h> \endcode
  35               	
  36               	    This header file includes the apropriate IO definitions for the
  37               	    device that has been specified by the <tt>-mmcu=</tt> compiler
  38               	    command-line switch.  This is done by diverting to the appropriate
  39               	    file <tt>&lt;avr/io</tt><em>XXXX</em><tt>.h&gt;</tt> which should
  40               	    never be included directly.  Some register names common to all
  41               	    AVR devices are defined directly within <tt>&lt;avr/io.h&gt;</tt>,
  42               	    but most of the details come from the respective include file.
  43               	
  44               	    Note that this file always includes
  45               	    \code #include <avr/sfr_defs.h> \endcode
  46               	    See \ref avr_sfr for the details.
  47               	
  48               	    Included are definitions of the IO register set and their
  49               	    respective bit values as specified in the Atmel documentation.
  50               	    Note that Atmel is not very consistent in its naming conventions,
  51               	    so even identical functions sometimes get different names on
  52               	    different devices.
  53               	
  54               	    Also included are the specific names useable for interrupt
  55               	    function definitions as documented
  56               	    \ref avr_signames "here".
  57               	
  58               	    Finally, the following macros are defined:
  59               	
  60               	    - \b RAMEND
  61               	    <br>
  62               	    A constant describing the last on-chip RAM location.
  63               	    <br>
  64               	    - \b XRAMEND
  65               	    <br>
  66               	    A constant describing the last possible location in RAM.
  67               	    This is equal to RAMEND for devices that do not allow for
  68               	    external RAM.
  69               	    <br>
  70               	    - \b E2END
  71               	    <br>
  72               	    A constant describing the address of the last EEPROM cell.
  73               	    <br>
  74               	    - \b FLASHEND
  75               	    <br>
  76               	    A constant describing the last byte address in flash ROM.
  77               	    <br>
  78               	    - \b SPM_PAGESIZE
  79               	    <br>
  80               	    For devices with bootloader support, the flash pagesize
  81               	    (in bytes) to be used for the \c SPM instruction. */
  82               	
  83               	#ifndef _AVR_IO_H_
  84               	#define _AVR_IO_H_
  85               	
  86               	#include <avr/sfr_defs.h>
   1               	/* Copyright (c) 2002, Marek Michalkiewicz <marekm@amelek.gda.pl>
   2               	   All rights reserved.
   3               	
   4               	   Redistribution and use in source and binary forms, with or without
   5               	   modification, are permitted provided that the following conditions are met:
   6               	
   7               	   * Redistributions of source code must retain the above copyright
   8               	     notice, this list of conditions and the following disclaimer.
   9               	
  10               	   * Redistributions in binary form must reproduce the above copyright
  11               	     notice, this list of conditions and the following disclaimer in
  12               	     the documentation and/or other materials provided with the
  13               	     distribution.
  14               	
  15               	   * Neither the name of the copyright holders nor the names of
  16               	     contributors may be used to endorse or promote products derived
  17               	     from this software without specific prior written permission.
  18               	
  19               	   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20               	   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21               	   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22               	   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23               	   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24               	   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25               	   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26               	   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27               	   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28               	   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29               	   POSSIBILITY OF SUCH DAMAGE.  */
  30               	
  31               	/* avr/sfr_defs.h - macros for accessing AVR special function registers */
  32               	
  33               	/* $Id: sfr_defs.h,v 1.16.2.2 2006/05/17 08:25:10 joerg_wunsch Exp $ */
  34               	
  35               	#ifndef _AVR_SFR_DEFS_H_
  36               	#define _AVR_SFR_DEFS_H_ 1
  37               	
  38               	/** \defgroup avr_sfr_notes Additional notes from <avr/sfr_defs.h>
  39               	    \ingroup avr_sfr
  40               	
  41               	   The \c <avr/sfr_defs.h> file is included by all of the \c <avr/ioXXXX.h>
  42               	   files, which use macros defined here to make the special function register
  43               	   definitions look like C variables or simple constants, depending on the
  44               	   <tt>_SFR_ASM_COMPAT</tt> define.  Some examples from \c <avr/iocanxx.h> to
  45               	   show how to define such macros:
  46               	
  47               	\code
  48               	#define PORTA   _SFR_IO8(0x02)
  49               	#define EEAR    _SFR_IO16(0x21)
  50               	#define UDR0    _SFR_MEM8(0xC6)
  51               	#define TCNT3   _SFR_MEM16(0x94)
  52               	#define CANIDT  _SFR_MEM32(0xF0)
  53               	\endcode
  54               	
  55               	   If \c _SFR_ASM_COMPAT is not defined, C programs can use names like
  56               	   <tt>PORTA</tt> directly in C expressions (also on the left side of
  57               	   assignment operators) and GCC will do the right thing (use short I/O
  58               	   instructions if possible).  The \c __SFR_OFFSET definition is not used in
  59               	   any way in this case.
  60               	
  61               	   Define \c _SFR_ASM_COMPAT as 1 to make these names work as simple constants
  62               	   (addresses of the I/O registers).  This is necessary when included in
  63               	   preprocessed assembler (*.S) source files, so it is done automatically if
  64               	   \c __ASSEMBLER__ is defined.  By default, all addresses are defined as if
  65               	   they were memory addresses (used in \c lds/sts instructions).  To use these
  66               	   addresses in \c in/out instructions, you must subtract 0x20 from them.
  67               	
  68               	   For more backwards compatibility, insert the following at the start of your
  69               	   old assembler source file:
  70               	
  71               	\code
  72               	#define __SFR_OFFSET 0
  73               	\endcode
  74               	
  75               	   This automatically subtracts 0x20 from I/O space addresses, but it's a
  76               	   hack, so it is recommended to change your source: wrap such addresses in
  77               	   macros defined here, as shown below.  After this is done, the
  78               	   <tt>__SFR_OFFSET</tt> definition is no longer necessary and can be removed.
  79               	
  80               	   Real example - this code could be used in a boot loader that is portable
  81               	   between devices with \c SPMCR at different addresses.
  82               	
  83               	\verbatim
  84               	<avr/iom163.h>: #define SPMCR _SFR_IO8(0x37)
  85               	<avr/iom128.h>: #define SPMCR _SFR_MEM8(0x68)
  86               	\endverbatim
  87               	
  87               	
  88               	#ifndef __AVR_HAVE_MOVW__
  89               	#  if  defined(__AVR_ENHANCED__) && __AVR_ENHANCED__
  90               	#   define __AVR_HAVE_MOVW__ 1
  91               	#  endif
  92               	#endif
  93               	
  94               	#ifndef __AVR_HAVE_LPMX__
  95               	# if  defined(__AVR_ENHANCED__) && __AVR_ENHANCED__
  96               	#  define __AVR_HAVE_LPMX__ 1
  97               	# endif
  98               	#endif
  99               	
 100               	/*
 101               	 * Registers common to all AVR devices.
 102               	 */
 103               	
 104               	#if __AVR_ARCH__ != 1
 105               	/*
 106               	 * AVR architecture 1 has no RAM, thus no stack pointer.
 107               	 *
 108               	 * All other archs do have a stack pointer.  Some devices have only
 109               	 * less than 256 bytes of possible RAM locations (128 Bytes of SRAM
 110               	 * and no option for external RAM), thus SPH is officially "reserved"
 111               	 * for them.  We catch this case below after including the
 112               	 * device-specific ioXXXX.h file, by examining XRAMEND, and
 113               	 * #undef-ining SP and SPH in that case.
 114               	 */
 115               	/* Stack Pointer */
 116               	#define SP        _SFR_IO16(0x3D)
 117               	#define SPL       _SFR_IO8(0x3D)
 118               	#define SPH       _SFR_IO8(0x3E)
 119               	#endif /* #if __AVR_ARCH__ != 1 */
 120               	
 121               	/* Status REGister */
 122               	#define SREG      _SFR_IO8(0x3F)
 123               	
 124               	/* Status Register - SREG */
 125               	#define    SREG_I       7
 126               	#define    SREG_T       6
 127               	#define    SREG_H       5
 128               	#define    SREG_S       4
 129               	#define    SREG_V       3
 130               	#define    SREG_N       2
 131               	#define    SREG_Z       1
 132               	#define    SREG_C       0
 133               	
 134               	/* Pointer definition */
 135               	#if __AVR_ARCH__ != 1
 136               	/* avr1 has only the Z pointer */
 137               	#define    XL           r26
 138               	#define    XH           r27
 139               	#define    YL           r28
 140               	#define    YH           r29
 141               	#endif /* #if __AVR_ARCH__ != 1 */
 142               	#define    ZL           r30
 143               	#define    ZH           r31
 144               	
 145               	/*
 146               	 * Only few devices come without EEPROM.  In order to assemble the
 147               	 * EEPROM library components without defining a specific device, we
 148               	 * keep the EEPROM-related definitions here.
 149               	 */
 150               	#if defined(__COMPILING_AVR_LIBC__)
 151               	
 152               	/* EEPROM Control Register */
 153               	#define EECR	_SFR_IO8(0x1C)
 154               	
 155               	/* EEPROM Data Register */
 156               	#define EEDR	_SFR_IO8(0x1D)
 157               	
 158               	/* EEPROM Address Register */
 159               	#define EEAR	_SFR_IO16(0x1E)
 160               	#define EEARL	_SFR_IO8(0x1E)
 161               	#define EEARH	_SFR_IO8(0x1F)
 162               	
 163               	/* EEPROM Control Register */
 164               	#define    EERIE        3
 165               	#define    EEMWE        2
 166               	#define    EEWE         1
 167               	#define    EERE         0
 168               	
 169               	#endif /* __COMPILING_AVR_LIBC__ */
 170               	
 171               	#if defined (__AVR_AT94K__)
 172               	#  include <avr/ioat94k.h>
 173               	#elif defined (__AVR_AT43USB320__)
 174               	#  include <avr/io43u32x.h>
 175               	#elif defined (__AVR_AT43USB355__)
 176               	#  include <avr/io43u35x.h>
 177               	#elif defined (__AVR_AT76C711__)
 178               	#  include <avr/io76c711.h>
 179               	#elif defined (__AVR_AT86RF401__)
 180               	#  include <avr/io86r401.h>
 181               	#elif defined (__AVR_AT90PWM2__)
 182               	#  include <avr/io90pwmx.h>
 183               	#elif defined (__AVR_AT90PWM3__)
 184               	#  include <avr/io90pwmx.h>
 185               	#elif defined (__AVR_ATmega128__)
 186               	#  include <avr/iom128.h>
 187               	#elif defined (__AVR_ATmega1280__)
 188               	#  include <avr/iom1280.h>
 189               	#elif defined (__AVR_ATmega1281__)
 190               	#  include <avr/iom1281.h>
 191               	#elif defined (__AVR_ATmega2560__)
 192               	#  include <avr/iom2560.h>
 193               	#elif defined (__AVR_ATmega2561__)
 194               	#  include <avr/iom2561.h>
 195               	#elif defined (__AVR_AT90CAN32__)
 196               	#  include <avr/iocan32.h>
 197               	#elif defined (__AVR_AT90CAN64__)
 198               	#  include <avr/iocan64.h>
 199               	#elif defined (__AVR_AT90CAN128__)
 200               	#  include <avr/iocan128.h>
 201               	#elif defined (__AVR_AT90USB646__)
 202               	#  include <avr/iousb646.h>
 203               	#elif defined (__AVR_AT90USB647__)
 204               	#  include <avr/iousb647.h>
 205               	#elif defined (__AVR_AT90USB1286__)
 206               	#  include <avr/iousb1286.h>
 207               	#elif defined (__AVR_AT90USB1287__)
 208               	#  include <avr/iousb1287.h>
 209               	#elif defined (__AVR_ATmega64__)
 210               	#  include <avr/iom64.h>
 211               	#elif defined (__AVR_ATmega640__)
 212               	#  include <avr/iom640.h>
 213               	#elif defined (__AVR_ATmega644__)
 214               	#  include <avr/iom644.h>
 215               	#elif defined (__AVR_ATmega644P__)
 216               	#  include <avr/iom644.h>
 217               	#elif defined (__AVR_ATmega645__)
 218               	#  include <avr/iom645.h>
 219               	#elif defined (__AVR_ATmega6450__)
 220               	#  include <avr/iom6450.h>
 221               	#elif defined (__AVR_ATmega649__)
 222               	#  include <avr/iom649.h>
 223               	#elif defined (__AVR_ATmega6490__)
 224               	#  include <avr/iom6490.h>
 225               	#elif defined (__AVR_ATmega103__)
 226               	#  include <avr/iom103.h>
 227               	#elif defined (__AVR_ATmega32__)
 228               	#  include <avr/iom32.h>
 229               	#elif defined (__AVR_ATmega323__)
 230               	#  include <avr/iom323.h>
 231               	#elif defined (__AVR_ATmega324P__)
 232               	#  include <avr/iom324.h>
 233               	#elif defined (__AVR_ATmega325__)
 234               	#  include <avr/iom325.h>
 235               	#elif defined (__AVR_ATmega3250__)
 236               	#  include <avr/iom3250.h>
 237               	#elif defined (__AVR_ATmega329__)
 238               	#  include <avr/iom329.h>
 239               	#elif defined (__AVR_ATmega3290__)
 240               	#  include <avr/iom3290.h>
 241               	#elif defined (__AVR_ATmega406__)
 242               	#  include <avr/iom406.h>
 243               	#elif defined (__AVR_ATmega16__)
 244               	#  include <avr/iom16.h>
 245               	#elif defined (__AVR_ATmega161__)
 246               	#  include <avr/iom161.h>
 247               	#elif defined (__AVR_ATmega162__)
 248               	#  include <avr/iom162.h>
 249               	#elif defined (__AVR_ATmega163__)
 250               	#  include <avr/iom163.h>
 251               	#elif defined (__AVR_ATmega164P__)
 252               	#  include <avr/iom164.h>
 253               	#elif defined (__AVR_ATmega165__)
 254               	#  include <avr/iom165.h>
 255               	#elif defined (__AVR_ATmega165P__)
 256               	#  include <avr/iom165p.h>
 257               	#elif defined (__AVR_ATmega168__)
 258               	#  include <avr/iom168.h>
   1               	/* Copyright (c) 2004, Theodore A. Roth
   2               	   All rights reserved.
   3               	
   4               	   Redistribution and use in source and binary forms, with or without
   5               	   modification, are permitted provided that the following conditions are met:
   6               	
   7               	   * Redistributions of source code must retain the above copyright
   8               	     notice, this list of conditions and the following disclaimer.
   9               	
  10               	   * Redistributions in binary form must reproduce the above copyright
  11               	     notice, this list of conditions and the following disclaimer in
  12               	     the documentation and/or other materials provided with the
  13               	     distribution.
  14               	
  15               	   * Neither the name of the copyright holders nor the names of
  16               	     contributors may be used to endorse or promote products derived
  17               	     from this software without specific prior written permission.
  18               	
  19               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29               	  POSSIBILITY OF SUCH DAMAGE. */
  30               	
  31               	/* $Id: iom168.h,v 1.2 2004/11/02 18:16:07 arcanum Exp $ */
  32               	
  33               	#ifndef _AVR_IOM168_H_
  34               	#define _AVR_IOM168_H_ 1
  35               	
  36               	#include <avr/iomx8.h>
   1               	/* Copyright (c) 2004,2005, Theodore A. Roth
   2               	   All rights reserved.
   3               	
   4               	   Redistribution and use in source and binary forms, with or without
   5               	   modification, are permitted provided that the following conditions are met:
   6               	
   7               	   * Redistributions of source code must retain the above copyright
   8               	     notice, this list of conditions and the following disclaimer.
   9               	
  10               	   * Redistributions in binary form must reproduce the above copyright
  11               	     notice, this list of conditions and the following disclaimer in
  12               	     the documentation and/or other materials provided with the
  13               	     distribution.
  14               	
  15               	   * Neither the name of the copyright holders nor the names of
  16               	     contributors may be used to endorse or promote products derived
  17               	     from this software without specific prior written permission.
  18               	
  19               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29               	  POSSIBILITY OF SUCH DAMAGE. */
  30               	
  31               	/* $Id: iomx8.h,v 1.12 2005/11/10 22:19:07 joerg_wunsch Exp $ */
  32               	
  33               	/* avr/iomx8.h - definitions for ATmega48, ATmega88 and ATmega168 */
  34               	
  35               	#ifndef _AVR_IOMX8_H_
  36               	#define _AVR_IOMX8_H_ 1
  37               	
  37               	
  38               	/* Constants */
  39               	#define SPM_PAGESIZE 128
  40               	#define RAMEND      0x4FF
  41               	#define XRAMEND     0x4FF
  42               	#define E2END       0x1FF
  43               	#define FLASHEND    0x3FFF
  44               	
  45               	#endif /* _AVR_IOM168_H_ */
  46               	...
 259               	#elif defined (__AVR_ATmega169__)
 260               	#  include <avr/iom169.h>
 261               	#elif defined (__AVR_ATmega169P__)
 262               	#  include <avr/iom169p.h>
 263               	#elif defined (__AVR_ATmega8__)
 264               	#  include <avr/iom8.h>
 265               	#elif defined (__AVR_ATmega48__)
 266               	#  include <avr/iom48.h>
 267               	#elif defined (__AVR_ATmega88__)
 268               	#  include <avr/iom88.h>
 269               	#elif defined (__AVR_ATmega8515__)
 270               	#  include <avr/iom8515.h>
 271               	#elif defined (__AVR_ATmega8535__)
 272               	#  include <avr/iom8535.h>
 273               	#elif defined (__AVR_AT90S8535__)
 274               	#  include <avr/io8535.h>
 275               	#elif defined (__AVR_AT90C8534__)
 276               	#  include <avr/io8534.h>
 277               	#elif defined (__AVR_AT90S8515__)
 278               	#  include <avr/io8515.h>
 279               	#elif defined (__AVR_AT90S4434__)
 280               	#  include <avr/io4434.h>
 281               	#elif defined (__AVR_AT90S4433__)
 282               	#  include <avr/io4433.h>
 283               	#elif defined (__AVR_AT90S4414__)
 284               	#  include <avr/io4414.h>
 285               	#elif defined (__AVR_ATtiny22__)
 286               	#  include <avr/iotn22.h>
 287               	#elif defined (__AVR_ATtiny26__)
 288               	#  include <avr/iotn26.h>
 289               	#elif defined (__AVR_AT90S2343__)
 290               	#  include <avr/io2343.h>
 291               	#elif defined (__AVR_AT90S2333__)
 292               	#  include <avr/io2333.h>
 293               	#elif defined (__AVR_AT90S2323__)
 294               	#  include <avr/io2323.h>
 295               	#elif defined (__AVR_AT90S2313__)
 296               	#  include <avr/io2313.h>
 297               	#elif defined (__AVR_ATtiny2313__)
 298               	#  include <avr/iotn2313.h>
 299               	#elif defined (__AVR_ATtiny13__)
 300               	#  include <avr/iotn13.h>
 301               	#elif defined (__AVR_ATtiny25__)
 302               	#  include <avr/iotn25.h>
 303               	#elif defined (__AVR_ATtiny45__)
 304               	#  include <avr/iotn45.h>
 305               	#elif defined (__AVR_ATtiny85__)
 306               	#  include <avr/iotn85.h>
 307               	#elif defined (__AVR_ATtiny24__)
 308               	#  include <avr/iotn24.h>
 309               	#elif defined (__AVR_ATtiny44__)
 310               	#  include <avr/iotn44.h>
 311               	#elif defined (__AVR_ATtiny84__)
 312               	#  include <avr/iotn84.h>
 313               	#elif defined (__AVR_ATtiny261__)
 314               	#  include <avr/iotn261.h>
 315               	#elif defined (__AVR_ATtiny461__)
 316               	#  include <avr/iotn461.h>
 317               	#elif defined (__AVR_ATtiny861__)
 318               	#  include <avr/iotn861.h>
 319               	/* avr1: the following only supported for assembler programs */
 320               	#elif defined (__AVR_ATtiny28__)
 321               	#  include <avr/iotn28.h>
 322               	#elif defined (__AVR_AT90S1200__)
 323               	#  include <avr/io1200.h>
 324               	#elif defined (__AVR_ATtiny15__)
 325               	#  include <avr/iotn15.h>
 326               	#elif defined (__AVR_ATtiny12__)
 327               	#  include <avr/iotn12.h>
 328               	#elif defined (__AVR_ATtiny11__)
 329               	#  include <avr/iotn11.h>
 330               	#else
 331               	#  if !defined(__COMPILING_AVR_LIBC__)
 332               	#    warning "device type not defined"
 333               	#  endif
 334               	#endif
 335               	
 336               	#include <avr/portpins.h>
   1               	/* Copyright (c) 2003  Theodore A. Roth
   2               	   All rights reserved.
   3               	
   4               	   Redistribution and use in source and binary forms, with or without
   5               	   modification, are permitted provided that the following conditions are met:
   6               	
   7               	   * Redistributions of source code must retain the above copyright
   8               	     notice, this list of conditions and the following disclaimer.
   9               	
  10               	   * Redistributions in binary form must reproduce the above copyright
  11               	     notice, this list of conditions and the following disclaimer in
  12               	     the documentation and/or other materials provided with the
  13               	     distribution.
  14               	
  15               	   * Neither the name of the copyright holders nor the names of
  16               	     contributors may be used to endorse or promote products derived
  17               	     from this software without specific prior written permission.
  18               	
  19               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29               	  POSSIBILITY OF SUCH DAMAGE. */
  30               	
  31               	/* $Id: portpins.h,v 1.3.4.1 2006/03/10 16:22:38 aesok Exp $ */
  32               	
  33               	#ifndef _AVR_PORTPINS_H_
  34               	#define _AVR_PORTPINS_H_ 1
  35               	
  36               	/* This file should only be included from <avr/io.h>, never directly. */
  37               	
  38               	#ifndef _AVR_IO_H_
  39               	#  error "Include <avr/io.h> instead of this file."
  40               	#endif
  41               	
  42               	/* Define Generic PORTn, DDn, and PINn values. */
  43               	
  44               	/* Port Data Register (generic) */
  45               	#define    PORT7        7
  46               	#define    PORT6        6
  47               	#define    PORT5        5
  48               	#define    PORT4        4
  49               	#define    PORT3        3
  50               	#define    PORT2        2
  51               	#define    PORT1        1
  52               	#define    PORT0        0
  53               	
  54               	/* Port Data Direction Register (generic) */
  55               	#define    DD7          7
  56               	#define    DD6          6
  57               	#define    DD5          5
  58               	#define    DD4          4
  59               	#define    DD3          3
  60               	#define    DD2          2
  61               	#define    DD1          1
  62               	#define    DD0          0
  63               	
  64               	/* Port Input Pins (generic) */
  65               	#define    PIN7         7
  66               	#define    PIN6         6
  67               	#define    PIN5         5
  68               	#define    PIN4         4
  69               	#define    PIN3         3
  70               	#define    PIN2         2
  71               	#define    PIN1         1
  72               	#define    PIN0         0
  73               	
  74               	/* Define PORTxn values for all possible port pins. */
  75               	
  76               	/* PORT A */
  77               	
  78               	#if defined(PA0)
  79               	#  define PORTA0 PA0
  80               	#endif
  81               	#if defined(PA1)
  82               	#  define PORTA1 PA1
  83               	#endif
  84               	#if defined(PA2)
  85               	#  define PORTA2 PA2
  86               	#endif
  87               	#if defined(PA3)
  88               	#  define PORTA3 PA3
  89               	#endif
  90               	#if defined(PA4)
  91               	#  define PORTA4 PA4
  92               	#endif
  93               	#if defined(PA5)
  94               	#  define PORTA5 PA5
  95               	#endif
  96               	#if defined(PA6)
  97               	#  define PORTA6 PA6
  98               	#endif
  99               	#if defined(PA7)
 100               	#  define PORTA7 PA7
 101               	#endif
 102               	
 103               	/* PORT B */
 104               	
 105               	#if defined(PB0)
 106               	#  define PORTB0 PB0
 107               	#endif
 108               	#if defined(PB1)
 109               	#  define PORTB1 PB1
 110               	#endif
 111               	#if defined(PB2)
 112               	#  define PORTB2 PB2
 113               	#endif
 114               	#if defined(PB3)
 115               	#  define PORTB3 PB3
 116               	#endif
 117               	#if defined(PB4)
 118               	#  define PORTB4 PB4
 119               	#endif
 120               	#if defined(PB5)
 121               	#  define PORTB5 PB5
 122               	#endif
 123               	#if defined(PB6)
 124               	#  define PORTB6 PB6
 125               	#endif
 126               	#if defined(PB7)
 127               	#  define PORTB7 PB7
 128               	#endif
 129               	
 130               	/* PORT C */
 131               	
 132               	#if defined(PC0)
 133               	#  define PORTC0 PC0
 134               	#endif
 135               	#if defined(PC1)
 136               	#  define PORTC1 PC1
 137               	#endif
 138               	#if defined(PC2)
 139               	#  define PORTC2 PC2
 140               	#endif
 141               	#if defined(PC3)
 142               	#  define PORTC3 PC3
 143               	#endif
 144               	#if defined(PC4)
 145               	#  define PORTC4 PC4
 146               	#endif
 147               	#if defined(PC5)
 148               	#  define PORTC5 PC5
 149               	#endif
 150               	#if defined(PC6)
 151               	#  define PORTC6 PC6
 152               	#endif
 153               	#if defined(PC7)
 154               	#  define PORTC7 PC7
 155               	#endif
 156               	
 157               	/* PORT D */
 158               	
 159               	#if defined(PD0)
 160               	#  define PORTD0 PD0
 161               	#endif
 162               	#if defined(PD1)
 163               	#  define PORTD1 PD1
 164               	#endif
 165               	#if defined(PD2)
 166               	#  define PORTD2 PD2
 167               	#endif
 168               	#if defined(PD3)
 169               	#  define PORTD3 PD3
 170               	#endif
 171               	#if defined(PD4)
 172               	#  define PORTD4 PD4
 173               	#endif
 174               	#if defined(PD5)
 175               	#  define PORTD5 PD5
 176               	#endif
 177               	#if defined(PD6)
 178               	#  define PORTD6 PD6
 179               	#endif
 180               	#if defined(PD7)
 181               	#  define PORTD7 PD7
 182               	#endif
 183               	
 184               	/* PORT E */
 185               	
 186               	#if defined(PE0)
 187               	#  define PORTE0 PE0
 188               	#endif
 189               	#if defined(PE1)
 190               	#  define PORTE1 PE1
 191               	#endif
 192               	#if defined(PE2)
 193               	#  define PORTE2 PE2
 194               	#endif
 195               	#if defined(PE3)
 196               	#  define PORTE3 PE3
 197               	#endif
 198               	#if defined(PE4)
 199               	#  define PORTE4 PE4
 200               	#endif
 201               	#if defined(PE5)
 202               	#  define PORTE5 PE5
 203               	#endif
 204               	#if defined(PE6)
 205               	#  define PORTE6 PE6
 206               	#endif
 207               	#if defined(PE7)
 208               	#  define PORTE7 PE7
 209               	#endif
 210               	
 211               	/* PORT F */
 212               	
 213               	#if defined(PF0)
 214               	#  define PORTF0 PF0
 215               	#endif
 216               	#if defined(PF1)
 217               	#  define PORTF1 PF1
 218               	#endif
 219               	#if defined(PF2)
 220               	#  define PORTF2 PF2
 221               	#endif
 222               	#if defined(PF3)
 223               	#  define PORTF3 PF3
 224               	#endif
 225               	#if defined(PF4)
 226               	#  define PORTF4 PF4
 227               	#endif
 228               	#if defined(PF5)
 229               	#  define PORTF5 PF5
 230               	#endif
 231               	#if defined(PF6)
 232               	#  define PORTF6 PF6
 233               	#endif
 234               	#if defined(PF7)
 235               	#  define PORTF7 PF7
 236               	#endif
 237               	
 238               	/* PORT G */
 239               	
 240               	#if defined(PG0)
 241               	#  define PORTG0 PG0
 242               	#endif
 243               	#if defined(PG1)
 244               	#  define PORTG1 PG1
 245               	#endif
 246               	#if defined(PG2)
 247               	#  define PORTG2 PG2
 248               	#endif
 249               	#if defined(PG3)
 250               	#  define PORTG3 PG3
 251               	#endif
 252               	#if defined(PG4)
 253               	#  define PORTG4 PG4
 254               	#endif
 255               	#if defined(PG5)
 256               	#  define PORTG5 PG5
 257               	#endif
 258               	#if defined(PG6)
 259               	#  define PORTG6 PG6
 260               	#endif
 261               	#if defined(PG7)
 262               	#  define PORTG7 PG7
 263               	#endif
 264               	
 265               	/* PORT H */
 266               	
 267               	#if defined(PH0)
 268               	#  define PORTH0 PH0
 269               	#endif
 270               	#if defined(PH1)
 271               	#  define PORTH1 PH1
 272               	#endif
 273               	#if defined(PH2)
 274               	#  define PORTH2 PH2
 275               	#endif
 276               	#if defined(PH3)
 277               	#  define PORTH3 PH3
 278               	#endif
 279               	#if defined(PH4)
 280               	#  define PORTH4 PH4
 281               	#endif
 282               	#if defined(PH5)
 283               	#  define PORTH5 PH5
 284               	#endif
 285               	#if defined(PH6)
 286               	#  define PORTH6 PH6
 287               	#endif
 288               	#if defined(PH7)
 289               	#  define PORTH7 PH7
 290               	#endif
 291               	
 292               	/* PORT J */
 293               	
 294               	#if defined(PJ0)
 295               	#  define PORTJ0 PJ0
 296               	#endif
 297               	#if defined(PJ1)
 298               	#  define PORTJ1 PJ1
 299               	#endif
 300               	#if defined(PJ2)
 301               	#  define PORTJ2 PJ2
 302               	#endif
 303               	#if defined(PJ3)
 304               	#  define PORTJ3 PJ3
 305               	#endif
 306               	#if defined(PJ4)
 307               	#  define PORTJ4 PJ4
 308               	#endif
 309               	#if defined(PJ5)
 310               	#  define PORTJ5 PJ5
 311               	#endif
 312               	#if defined(PJ6)
 313               	#  define PORTJ6 PJ6
 314               	#endif
 315               	#if defined(PJ7)
 316               	#  define PORTJ7 PJ7
 317               	#endif
 318               	
 319               	/* PORT K */
 320               	
 321               	#if defined(PK0)
 322               	#  define PORTK0 PK0
 323               	#endif
 324               	#if defined(PK1)
 325               	#  define PORTK1 PK1
 326               	#endif
 327               	#if defined(PK2)
 328               	#  define PORTK2 PK2
 329               	#endif
 330               	#if defined(PK3)
 331               	#  define PORTK3 PK3
 332               	#endif
 333               	#if defined(PK4)
 334               	#  define PORTK4 PK4
 335               	#endif
 336               	#if defined(PK5)
 337               	#  define PORTK5 PK5
 337               	
 338               	#if __AVR_ARCH__ != 1
 339               	#  if XRAMEND < 0x100 && !defined(__COMPILING_AVR_LIBC__)
 340               	#    undef SP
 341               	#    define SP     _SFR_IO8(0x3D)
 342               	#    undef SPH
 343               	#  endif
 344               	#endif
 345               	
 346               	#include <avr/version.h>
   1               	/* Copyright (c) 2005, Joerg Wunsch                               -*- c -*-
   2               	   All rights reserved.
   3               	
   4               	   Redistribution and use in source and binary forms, with or without
   5               	   modification, are permitted provided that the following conditions are met:
   6               	
   7               	   * Redistributions of source code must retain the above copyright
   8               	     notice, this list of conditions and the following disclaimer.
   9               	
  10               	   * Redistributions in binary form must reproduce the above copyright
  11               	     notice, this list of conditions and the following disclaimer in
  12               	     the documentation and/or other materials provided with the
  13               	     distribution.
  14               	
  15               	   * Neither the name of the copyright holders nor the names of
  16               	     contributors may be used to endorse or promote products derived
  17               	     from this software without specific prior written permission.
  18               	
  19               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29               	  POSSIBILITY OF SUCH DAMAGE. */
  30               	
  31               	/* $Id: version.h.in,v 1.1 2005/09/12 20:18:12 joerg_wunsch Exp $ */
  32               	
  33               	/** \defgroup avr_version <avr/version.h>: avr-libc version macros
  34               	    \code #include <avr/version.h> \endcode
  35               	
  36               	    This header file defines macros that contain version numbers and
  37               	    strings describing the current version of avr-libc.
  38               	
  39               	    The version number itself basically consists of three pieces that
  40               	    are separated by a dot: the major number, the minor number, and
  41               	    the revision number.  For development versions (which use an odd
  42               	    minor number), the string representation additionally gets the
  43               	    date code (YYYYMMDD) appended.
  44               	
  45               	    This file will also be included by \c <avr/io.h>.  That way,
  46               	    portable tests can be implemented using \c <avr/io.h> that can be
  47               	    used in code that wants to remain backwards-compatible to library
  48               	    versions prior to the date when the library version API had been
  49               	    added, as referenced but undefined C preprocessor macros
  50               	    automatically evaluate to 0.
  51               	*/
  52               	
  53               	#ifndef _AVR_VERSION_H_
  54               	#define _AVR_VERSION_H_
  55               	
  56               	/** \ingroup avr_version
  57               	    String literal representation of the current library version. */
  58               	#define __AVR_LIBC_VERSION_STRING__ "1.4.5"
  59               	
  60               	/** \ingroup avr_version
  61               	    Numerical representation of the current library version.
  62               	
  63               	    In the numerical representation, the major number is multiplied by
  64               	    10000, the minor number by 100, and all three parts are then
  65               	    added.  It is intented to provide a monotonically increasing
  66               	    numerical value that can easily be used in numerical checks.
  67               	 */
  68               	#define __AVR_LIBC_VERSION__        10405UL
  69               	
  70               	/** \ingroup avr_version
  71               	    String literal representation of the release date. */
  72               	#define __AVR_LIBC_DATE_STRING__    "20061009"
  73               	
  74               	/** \ingroup avr_version
  75               	    Numerical representation of the release date. */
  76               	#define __AVR_LIBC_DATE_            20061009UL
  77               	
  78               	/** \ingroup avr_version
  79               	    Library major version number. */
  80               	#define __AVR_LIBC_MAJOR__          1
  81               	
  82               	/** \ingroup avr_version
  83               	    Library minor version number. */
  84               	#define __AVR_LIBC_MINOR__          4
  85               	
  86               	/** \ingroup avr_version
  87               	    Library revision number. */
  88               	#define __AVR_LIBC_REVISION__       5
  89               	
  90               	#endif /* _AVR_VERSION_H_ */
  91               	...
 347               	
   5               	#else
   6               	#include <ioavr.h>
   7               	#endif
   8               	
   9               	...
  26               	
  27               	#ifdef __IAR_SYSTEMS_ASM__
  28               	
  29               	__global  MACRO Label, Size
  30               	//        EXTERN  `?<Segment init: NEAR_Z>`
  31               	//	REQUIRE `?<Segment init: NEAR_Z>`
  32               	        PUBLIC Label
  33               	        RSEG NEAR_Z:DATA:NOROOT(0)
  34               	Label:  DS Size
  35               	        ENDM
  36               	
  37               	__static MACRO Label, Size
  38               	//        EXTERN  `?<Segment init: NEAR_Z>`
  39               	//	REQUIRE `?<Segment init: NEAR_Z>`
  40               	        RSEG NEAR_Z:DATA:NOROOT(0)
  41               	Label:  DS Size
  42               	        ENDM
  43               	
  44               	#  define _GLOBAL(Label, Size) __global Label, Size
  45               	#  define _STATIC(Label, Size) __static Label, Size
  46               	#  define _DATASECTION RSEG AVRXDATA:DATA
  47               	#  define _CODESECTION RSEG CODE:CODE
  48               	#  define _FUNCTION(A) PUBLIC A
  49               	#  define _ENDFUNC
  50               	#  define _PUBLIC(A) PUBLIC A
  51               	#  define _EXTERN(A) EXTERN A
  52               	#  define _MODULE(A) MODULE A
  53               	#  define _ENDMOD ENDMOD
  54               	#  define _END END
  55               	#  define lo8_pm(A) LOW(A/2)
  56               	#  define hi8_pm(A) HIGH(A/2)
  57               	#  define lo8(A) LOW(A)
  58               	#  define hi8(A) HIGH(A)
  59               	#  define _DB DB
  60               	#  define _EQU(A,B) A: EQU B
  61               	#  define _ALIGN EVEN
  62               	#  define _SFR_IO_ADDR(A) (A)   /* IAR does not use this */
  63               	
  64               	#else   /*avr-gcc*/
  65               	
  66               	#  if !defined(_SFR_IO_ADDR)      /* GCC 3.2 compatibility */
  67               	#    define _SFR_IO_ADDR(A) (A)   /* earlier compilers do not use this */
  68               	#  endif
  69               	#  define _GLOBAL(Label, Size) .comm Label, Size
  70               	#  define _STATIC(Label, Size) .lcomm Label, Size
  71               	#  define _DATASECTION
  72               	#  define _CODESECTION
  73               	#  define _FUNCTION(A) \
  74               	        .global A $ \
  75               	        .func   A
  76               	#  define _ENDFUNC .endfunc
  77               	#  define _PUBLIC(A) .global A
  78               	#  define _EXTERN(A)
  79               	#  define _MODULE(A) .section .text.avrx.A
  80               	#  define _ENDMOD
  81               	#  define _END
  82               	#  define _DB .asciz
  83               	#  define MACRO .macro
  84               	#  define ENDM .endm
  85               	#  define _EQU(A,B) .equ A, B
  86               	#  define _ALIGN .balign 2
  87               	
  88               	#endif
  89               	
  90               	#ifndef BV
  91               	#define BV(A) (1<<A)
  92               	#endif
  93               	
  94               	/*
  95               	 Frame Pointer Offsets for various registers after the return from
  96               	 a call to _Prolog
  97               	
  98               	 Used mainly to restore registers used internally (rather than saving
  99               	 and restoring) and to stuff return values across _Epilog.
 100               	
 101               	*/
 102               	#define _RetLo  33      /* Return address on stack big endian */
 103               	#define _R31    33      /* Registers saved in order (little endian) */
 104               	#define _RetHi  32
 105               	#define _R30    32
 106               	#define _R29    31
 107               	#define _R28    30
 108               	#define _R27    29
 109               	#define _R26    28
 110               	#define _R25    27
 111               	#define _R24    26
 112               	#define _R23    25
 113               	#define _R22    24
 114               	#define _R0     2
 115               	#define _SREG   1       /* SP points below last saved item */
 116               	
 117               	#ifdef __IAR_SYSTEMS_ASM__
 118               	
 119               	#  define _p1l     18
 120               	#  define _p1h     19
 121               	#  define _p2l     22
 122               	#  define _p2h     23
 123               	#  define _r1l     18
 124               	#  define _r1h     19
 125               	
 126               	#else   /* avr-gcc */
 127               	
 128               	#  define _p1l     26
 129               	#  define _p1h     27
 130               	#  define _p2l     24
 131               	#  define _p2h     25
 132               	#  define _r1l     26
 133               	#  define _r1h     27
 134               	
 135               	#endif
 136               	
 137               	/* ******** AVRX kernel data structure offsets
 138               	   These are offsets into a slab of memory called "AvrXKernelData"
 139               	   defined in avrx_tasking.s
 140               	
 141               	   NB: CODE depends upon RunQueue being the FIRST item!
 142               	*/
 143               	
 144               	#define RunQueue 0	/* Head of the run queue */
 145               	#define Running 2	/* Current running task */
 146               	#define AvrXStack 4	/* User defined stack location */
 147               	#define SysLevel 6	/* re-entry counter into kernel context */
 148               	#define AvrXCStack 7	/* IAR/ICC C Parameter stack */
 149               	
 150               	#ifdef  __IAR_SYSTEMS_ASM__
 151               	#	define AvrXKernelDataSz 9
 152               	#else
 153               	#	define AvrXKernelDataSz 7
 154               	#endif
 155               	
 156               	/* ******** TCB (Task Control Block) offsets */
 157               	
 158               	#define TaskSP          0       /* Stack pointer */
 159               	#define TaskMain        2       /* Entry point of process */
 160               	#define TaskPid         4       /* Pointer to Process ID */
 161               	#define TaskFlags       6       /* Priority */
 162               	
 163               	#define TaskSz  7
 164               	
 165               	/* All objects have same link list structure
 166               	   Change this to convert to big-endian for direct C access
 167               	*/
 168               	
 169               	#define NextL 0		/* Big-endian for C compatibility */
 170               	#define NextH 1
 171               	
 172               	/******** PID (Process ID) block offsets */
 173               	
 174               	#define PidNext         0       /* Next item on list (semaphore, run) */
 175               	#define PidState        2       /* Upper Nibble: Task flags, Lower Nibble :Priority */
 176               	#define PidPriority     3
 177               	#define PidSP           4       /* Context Pointer */
 178               	#ifdef SINGLESTEPSUPPORT
 179               	#   define bp1          6       /* Make room for two breakpoints/task */
 180               	#   define bp2          8
 181               	#   define PidSz        10
 182               	#else
 183               	#   define PidSz        6
 184               	#endif
 185               	
 186               	/* ******* PID (Process ID) BLOCK BIT DEFINITIONS ******* */
 187               	
 188               	/* PID.State  */
 189               	
 190               	#define IdleBit         4       /* Dead Task, don't schedule, resume or step */
 191               	#define SuspendBit      5       /* Mark task for suspension (may be blocked elsewhere) */
 192               	#define SuspendedBit    6       /* Mark task suspended (it was removed from the run queue) */
 193               	#define SingleStep      7       /* Enable single step debug support */
 194               	
 195               	/*+ --------------------------------------------------
 196               	SEMAPHORE BIT DEFINITIONS
 197               	
 198               	 General Semaphore Flags.  When a task is waiting on the
 199               	 semaphore, the semaphore is set to the TASK ID.  Otherwise
 200               	 _PEND means the semaphore is set and _DONE means it has
 201               	 been triggered.  A task will only block if it tries to
 202               	 grab a _PEND semaphore.  Semaphores are initialized in the
 203               	 _PEND state and are left in the _PEND state after each
 204               	 complete operation.  Processes are allowed to queue on
 205               	 a semaphore.  This effectively make the semaphore a Mutex
 206               	 when it has been "set" prior to the first call.  When a process
 207               	 done with the mutex, it releases it by "setting" it again.
 208               	-*/
 209               	#define _PEND           0
 210               	#define _DONE           1
 211               	
 212               	#define MtxSz           2
 213               	
 214               	#define MUTEX(A) _GLOBAL(A, 2)
 215               	
 216               	/*+ --------------------------------------------------
 217               	
 218               	 Events
 219               	
 220               	 Events replace PID's in semaphores.  The kernel recognizes
 221               	 semaphore values (contents) < 0x60 as events, indexes into
 222               	 a table and calls a routine.  Macros and segments are used
 223               	 to build the table.
 224               	
 225               	 */
 226               	#define TIMERMESSAGE_EV 2
 227               	#define PERIODICTIMER_EV 3      /* Not implemented */
 228               	#define _LASTEV 0x5F
 229               	
 230               	/* Timers */
 231               	
 232               	#define TcbNext         0       /* Pointer in linked list */
 233               	#define TcbSemaphore    2       /* Associated semaphore */
 234               	#define TcbCount        4       /* Timer ticks till expired */
 235               	#define TcbQueue        6
 236               	#define TcbSz           6       /* Primitive Timer */
 237               	#define TmbSz           8       /* Timer Message */
 238               	
 239               	#define TIMER(A) _GLOBAL(A, TcbSz)
 240               	
 241               	#define TIMERMESSAGE(A) _GLOBAL(A, TmbSz)
 242               	
 243               	/* Message Queue */
 244               	
 245               	#define MsqSz           4       /* Head of message queue */
 246               	
 247               	#define MsqMessage      0       /* Head of list of messages */
 248               	#define MsqPid          2       /* Head of list of waiting processes */
 249               	
 250               	#define QcbSz           4       /* Queue Block Size (No data) */
 251               	
 252               	#define QcbNext         0
 253               	#define QcbSemaphore    2       /* Return Receipt Semaphore */
 254               	#define QcbData         4       /* pointer to data/or data */
 255               	
 256               	#define MESSAGEQ(A) _GLOBAL(A, MsqSz)
 257               	
 258               	/* Fifos */
 259               	
 260               	#define FifoSz 4        /* Size of AvrX Fifo Data Struct */
 261               	
 262               	#define WriteSemaphore 0
 263               	#define ReadSemaphore 2
 264               	#define fBuffer 4
 265               	
 266               	/* User Section */
 267               	
 268               	#define f_buffersz 4    /* Size of buffer header */
 269               	
 270               	#define f_Size 0
 271               	#define f_Count 1
 272               	#define f_In 2
 273               	#define f_Out 3
 274               	#define f_Data 4        /* Variable length */
 275               	
 276               	#define FIFO(A, B, Size) \
 277               	        _GLOBAL(A, FifoSz) \
 278               	        _GLOBAL(B, (Size+f_Buffersz))
 279               	
 280               	#ifndef AVRXCHEADER
 281               	/*+ --------------------------------------------------
 282               	 Handy Macros
 283               	
 284               	 DEBUG statements are diagnostics for twiddling and output port bit
 285               	 to reflect the I bit state (interrupt latency) and when AvrX is in
 286               	 the Idle loop
 287               	-*/
 288               	#ifdef  DEBUG           /* DEBUG is set to a PORT{ABCD} value (for twiddling output bits) */
 289               	
 290               	#ifndef ILED
 291               	#define ILED            PB0
 292               	#endif
 293               	
 294               	#ifndef IDLELED
 295               	#define IDLELED         PB4
 296               	#endif
 297               	
 298               	#define DEBUG_DDR       (DEBUG-1)
 299               	
 300               	#endif  /* DEBUG */
 301               	
 302               	        MACRO  Breakpoint
 303               	#ifdef  DEBUG
 304               	        rcall   AvrXBreakpoint
 305               	#endif  /* DEBUG */
 306               	        ENDM
 307               	
 308               	        MACRO  BeginInterrupt
 309               	#ifdef  DEBUG
 310               	        cbi     DEBUG, ILED
 311               	        sbi     DEBUG, IDLELED  /* Obviously not idle... */
 312               	#endif  /* DEBUG */
 313               	        ENDM
 314               	
 315               	        MACRO  EndInterrupt
 316               	#ifdef  DEBUG
 317               	        sbi     DEBUG, ILED
 318               	#endif  /* DEBUG */
 319               	        reti
 320               	        ENDM
 321               	
 322               	        MACRO BeginCritical
 323               	#ifdef  DEBUG
 324               	        cbi     DEBUG, ILED
 325               	#endif  /* DEBUG */
 326               	        cli     ;
 327               	        ENDM
 328               	
 329               	        MACRO  EndCritical
 330               	#ifdef  DEBUG
 331               	        sbi     DEBUG, ILED
 332               	#endif  /* DEBUG */
 333               	        sei
 334               	        ENDM
 335               	
 336               	#define EndCriticalReturn EndInterrupt
 337               	
 338               	        MACRO  BeginIdle
 339               	snore:
 340               	#ifdef  DEBUG
 341               	        cbi     DEBUG, IDLELED
 342               	#endif  /* DEBUG */
 343               	        ENDM
 344               	
 345               	        MACRO  EndIdle
 346               	snooze:
 347               	#ifdef  DEBUG
 348               	        sbi     DEBUG, IDLELED
 349               	#endif  /* DEBUG */
 350               	        ENDM
 351               	
 352               	        MACRO  INIT_DEBUG
 353               	#ifdef  DEBUG
 354               	        ldi     Xl, (1<<ILED | 1<<IDLELED)
 355               	        out     DEBUG_DDR, Xl
 356               	        out     DEBUG, Xl
 357               	#endif  /* DEBUG */
 358               	        ENDM
 359               	
 360               	/*+ --------------------------------------------------
 361               	 Handy macros for common assembly chores
 362               	-*/
 363               	        MACRO  SignExtend Dest, Source
 364               	        clr     Dest
 365               	        sbrc    Source, 7
 366               	        com     Dest
 367               	        ENDM
 368               	
 369               	        MACRO  addi reg, val
 370               	        subi    reg, -(val)
 371               	        ENDM
 372               	
 373               	        MACRO  adci reg, val
 374               	        sbci    reg, -(val)
 375               	        ENDM
 376               	
 377               	        MACRO  tstw reg
 378               	        adiw    reg, 0
 379               	        ENDM
 380               	
 381               	        MACRO  negw regh, regl
 382               	        com     regh
 383               	        neg     regl
 384               	        sbci    regh, -1
 385               	        ENDM
 386               	/*
 387               	 Use this macro rather than a call to _Prolog, see
 388               	 version notes in AvrX.asm
 389               	*/
 390               	        MACRO  AVRX_Prolog
 391               	        BeginCritical
 392               	        rcall   IntProlog
 393               	        EndCritical
 394               	        ENDM
 395               	/*
  52               	// #include	"io-avr.h"	/* this is included in avrx.inc */
  53               	// #include	"avrx-signal.h" /* this is obsolete > 3.02 */
  54               	
  55               	        _MODULE(serialio)
  56               	        _EXTERN(_Epilog)
  57               	        _EXTERN(IntProlog)
  58               	        _EXTERN(AvrXWaitSemaphore)
  59               	        _EXTERN(AvrXIntSetSemaphore)
  60               	;
  61               	; Needed for USART interrupt
  62               	; Asynch, 8 bit, no parity, one stop, USART 0. is assumed in this code
  63               	;
  64               	#define UCR_INIT  lo8((1<<TXEN) | (1<<RXEN) | (1<<RXCIE))
  65               	#define UCRC_INIT (BV(UCSZ1) | BV(UCSZ0))	/* mega128 only */
  66               	
  67               	// UBRR_INIT is an external value defined by user application.
  68               	
  69               	//#define UBRR_INIT lo8((CPUCLK)/(16 * BAUDRATE) - 1)
  70               	
  71               	#define CharPushed 7
  72               	
  73               	; Mega chips re-define the UCR/USR.  The 161 has two usarts
  74               	; can't do the easy thing since IAR doesn't "#define" the io addresses
  75               	; The below is a cop-out: if the alternate names are "defined" then
  76               	; simply redefine the old names to match.
  77               	
  78               	#if defined(UCSRB)
  79               	#	define UCR UCSRB
  80               	#endif
  81               	#if defined(UCSRA)
  82               	#	define USR UCSRA
  83               	#endif
  84               	#if defined(UCSR0B)
  85               	#	define UCR UCSR0B
  86               	#endif
  87               	#if defined(UCSR0A)
  88               	#	define USR UCSR0A
  89               	#endif
  90               	#if defined(UDR0)
  91               	#	define UDR UDR0
  92               	#endif
  93               	#if defined(UBRR0L)
  94               	#	define UBRR UBRR0L
  95               	#endif
  96               	#if defined(SIG_UART0_RECV)
  97               	#    define SIG_UART_RECV SIG_UART0_RECV
  98               	#    define SIG_UART_DATA SIG_UART0_DATA
  99               	#elif defined (SIG_USART0_RECV)
 100               	#    define SIG_UART_RECV SIG_USART0_RECV
 101               	#    define SIG_UART_DATA SIG_USART0_DATA
 102               	#endif
 103               	
 104               	// A special just for IAR
 105               	
 106               	#if defined(__AT90Mega163__) || defined(__AT90Mega83__)
 107               	#  define UBRR UBRRLO
 108               	#endif
 109               	
 110               	
 111               	        _DATASECTION
 112               	
 113               	        _GLOBAL(SioFlags,1)
 114               	        _GLOBAL(_RxByte, 1)
 115               	        _GLOBAL(RxC_Flag, MtxSz)
 116               	        _GLOBAL(TxIntFlag, MtxSz)
 117               	
 118               	        _CODESECTION
 119               	;+
 120               	;------------------------------------------
 121               	; PushChar
 122               	;
 123               	; Set a flag so that the next call to GetChar just returns.
 124               	; in effect pushing the last returned charactor to be retrieved
 125               	; by the next routine
 126               	;-
 127               	        _FUNCTION(PushChar)
 128               	PushChar:
 129:../avrx/serialio.S ****         push    Xl
 130:../avrx/serialio.S ****         lds     Xl, SioFlags
 131:../avrx/serialio.S ****         sbr     Xl, 1<<CharPushed
 132:../avrx/serialio.S ****         sts     SioFlags, Xl
 133:../avrx/serialio.S ****         pop     Xl
 134:../avrx/serialio.S ****         ret
 135               	        _ENDFUNC
 136               	;+
 137               	;------------------------------------------
 138               	; GetChar
 139               	;
 140               	; Need to make this draw from a buffer so that multiple
 141               	; chars can be pushed... and so different input streams
 142               	; can be attached to the buffer.
 143               	;-
 144               	        _FUNCTION(GetChar)
 145               	#ifdef  __IAR_SYSTEMS_ASM__
 146               	        PUBLIC  ?C_GETCHAR
 147               	?C_GETCHAR:     ; Need this label for simulator I/O
 148               	#endif
 149               	GetChar:
 150:../avrx/serialio.S ****         lds     tmp0, SioFlags
 151:../avrx/serialio.S ****         sbrs    tmp0, CharPushed
 152:../avrx/serialio.S ****         rjmp    gc00
 153:../avrx/serialio.S ****         cbr     tmp0, 1<<CharPushed
 154:../avrx/serialio.S ****         rjmp    gc01
 155:../avrx/serialio.S ****         sts     SioFlags, tmp0
 156:../avrx/serialio.S ****         rjmp    gc01
 157               	gc00:
 158:../avrx/serialio.S ****         ldi     p1h, hi8(RxC_Flag)
 159:../avrx/serialio.S ****         ldi     p1l, lo8(RxC_Flag)
 160:../avrx/serialio.S ****         rcall   AvrXWaitSemaphore       ; Wait for a charactor, or flag from System
 161               	gc01:
 162:../avrx/serialio.S ****         lds     r1l, _RxByte
 163:../avrx/serialio.S ****         ret
 164               	        _ENDFUNC
 165               	;+
 166               	;------------------------------------------
 167               	; _GetChar
 168               	;
 169               	; Special version that echos
 170               	;
 171               	; RETURNS:      RxByte (Register)
 172               	;-
 173               	        _FUNCTION(_GetChar)
 174               	
 175               	_GetChar:
 176:../avrx/serialio.S ****         rcall   GetChar
 177:../avrx/serialio.S ****         rjmp    PutChar
 178               	        _ENDFUNC
 179               	;+
 180               	;------------------------------------------
 181               	;
 182               	; PutCR
 183               	;
 184               	; Put a CR to the output stream
 185               	;-
 186               	        _FUNCTION(PutCR)
 187               	PutCR:
 188:../avrx/serialio.S ****         ldi     p1l, 0x0D
 189:../avrx/serialio.S ****         rjmp    PutChar
 190               	        _ENDFUNC
 191               	;+
 192               	;------------------------------------------
 193               	;
 194               	; PutSpace
 195               	;
 196               	; Put a space to the output stream
 197               	;-
 198               	        _FUNCTION(PutSpace)
 199               	
 200               	PutSpace:
 201:../avrx/serialio.S ****         ldi     p1l, ' '
 202:../avrx/serialio.S ****         rjmp    PutChar
 203               	        _ENDFUNC
 204               	;+
 205               	;------------------------------------------
 206               	;
 207               	; const char * PutString(const char *)
 208               	;
 209               	; passed:
 210               	;       near pointer to string in FLASH memory
 211               	; Returns:
 212               	;       pointer to next char after NULL
 213               	;-
 214               	        _FUNCTION(_PrintString)
 215               	
 216               	_PrintString:
 217:../avrx/serialio.S ****         mov     Zl, p1l
 218:../avrx/serialio.S ****         mov     Zh, p1h
 219               	_foo:
 220:../avrx/serialio.S ****         lpm
 221:../avrx/serialio.S ****         tst     R0
 222:../avrx/serialio.S ****         breq    _ps00
 223:../avrx/serialio.S ****         mov     p1l, R0
 224:../avrx/serialio.S ****         push    Zl
 225:../avrx/serialio.S ****         push    Zh
 226:../avrx/serialio.S ****         rcall   PutChar
 227:../avrx/serialio.S ****         pop     Zh
 228:../avrx/serialio.S ****         pop     Zl
 229:../avrx/serialio.S ****         adiw    Zl, 1
 230:../avrx/serialio.S ****         rjmp    _foo
 231               	_ps00:
 232:../avrx/serialio.S ****         mov     r1l, Zl
 233:../avrx/serialio.S ****         mov     r1h, Zh
 234:../avrx/serialio.S ****         ret
 235               	        _ENDFUNC
 236               	;+
 237               	;-------------------------------------------
 238               	; void InitSerialIO(unsigned)
 239               	;
 240               	; PASSED:       R25:24 = UBBR
 241               	;		p1h:p1l = UBBR
 242               	;
 243               	; History: parameter used to be passed in R25 l.b. 1/31/01
 244               	;	   Changed to unsigned for mega chips. l.b. 5/30/02
 245               	;
 246               	        _FUNCTION(InitSerialIO)
 247               	InitSerialIO:
 248:../avrx/serialio.S ****        sts     UBRR0L, p1l
 249               	#if defined(UBRR0H)
 250:../avrx/serialio.S **** 	sts	UBRR0H, p1h	// THIS appears to be a no-op
 251               	#endif
 252               	#if defined(UCSR0C)
 253:../avrx/serialio.S **** 	ldi	tmp0, UCRC_INIT	// SET word length.
 254:../avrx/serialio.S **** 	sts	UCSR0C, tmp0	// Extended register in mega128
 255               	#endif
 256:../avrx/serialio.S ****         ldi     tmp0, UCR_INIT
 257:../avrx/serialio.S ****         sts     UCR0, tmp0
 258:../avrx/serialio.S ****         ret
 259               	        _ENDFUNC
 260               	;
 261               	;-----------------------------------------------
 262               	; UDRE_Interrupt
 263               	;
 264               	; Disables the interrupt (UDR is empty) signal waiting
 265               	; process to stuff the UDR
 266               	;
 267               	        _FUNCTION(SIG_UART_DATA)
 268               	SIG_UART_DATA:
 269:../avrx/serialio.S ****         cbi     _SFR_IO_ADDR(UCR0), UDRIE      ; Disable the interrupt
 270               	
 271:../avrx/serialio.S ****         rcall   IntProlog
 272               	
 273:../avrx/serialio.S ****         ldi     p1l, lo8(TxIntFlag)
 274:../avrx/serialio.S ****         ldi     p1h, hi8(TxIntFlag)
 275:../avrx/serialio.S ****         rcall   AvrXIntSetSemaphore     ; Signal we are ready for more.
 276               	
 277:../avrx/serialio.S ****         rjmp    _Epilog
 278               	        _ENDFUNC
 279               	
 280               	;
 281               	;-----------------------------------------------
 282               	; RxC_Interrupt
 283               	;
 284               	; Reads the USART and flags UserTask, Char In semaphore
 285               	;
 286               	        _FUNCTION(SIG_UART_RECV)
 287               	SIG_UART_RECV:
 288:../avrx/serialio.S ****         cbi     _SFR_IO_ADDR(UCR), RXCIE      ; disable interrupt
 289               	
 290:../avrx/serialio.S ****         rcall   IntProlog      ; Switch to kernel stack
 291               	
 292:../avrx/serialio.S ****         in      Xl, _SFR_IO_ADDR(UDR)
 293:../avrx/serialio.S ****         sts     _RxByte, Xl
 294               	
 295:../avrx/serialio.S ****         ldi     p1h, hi8(RxC_Flag)
 296:../avrx/serialio.S ****         ldi     p1l, lo8(RxC_Flag)
 297:../avrx/serialio.S ****         rcall   AvrXIntSetSemaphore
 298               	
 299:../avrx/serialio.S ****         sbi     _SFR_IO_ADDR(UCR), RXCIE      ; Re-enable interrupts
 300:../avrx/serialio.S ****         rjmp    _Epilog
 301               	        _ENDFUNC
 302               	;+
 303               	;------------------------------------------
 304               	; PutChar
 305               	;
 306               	; Passed: p1l "TxByte"
 307               	;
 308               	; Stuffs "TxByte" into usart.  The usart is double buffered.
 309               	; when the data register is full we wait on the semaphore
 310               	; until the Usart interrupts indicating the register is ready.
 311               	;-
 312               	        _FUNCTION(PutChar)
 313               	#ifdef __IAR_SYSTEMS_ASM__
 314               	        _PUBLIC(?C_PUTCHAR)     ; Enable terminal I/O
 315               	?C_PUTCHAR:
 316               	#endif
 317               	PutChar:
 318:../avrx/serialio.S ****         sbic    _SFR_IO_ADDR(USR), UDRE
 319:../avrx/serialio.S ****         rjmp    pc00
 320               	
 321:../avrx/serialio.S ****         push    p1l
 322:../avrx/serialio.S ****         sbi     _SFR_IO_ADDR(UCR), UDRIE      ; Enable interrupts and
 323:../avrx/serialio.S ****         ldi     p1l, lo8(TxIntFlag)
 324:../avrx/serialio.S ****         ldi     p1h, hi8(TxIntFlag)
 325:../avrx/serialio.S ****         rcall   AvrXWaitSemaphore; Wait until data register is ready
 326:../avrx/serialio.S ****         pop     p1l
 327               	pc00:
 328:../avrx/serialio.S ****         out     _SFR_IO_ADDR(UDR), p1l
 329:../avrx/serialio.S ****         ret
 330               	        _ENDFUNC
 331               	
 332               	;-----------------------------------------
 333               	; _GetHex
 334               	;
 335               	; PASSED:       p1l = Maximum number of digits
 336               	; RETURNS:      r1 = val, Tbit, p2l = Number of digits entered
 337               	; USES:         R24, R25
 338               	; STACK:        4
 339               	;
 340               	        _FUNCTION(_GetHex)
 341               	_GetHex:
 342:../avrx/serialio.S ****         push    R10
 343:../avrx/serialio.S ****         push    R11
 344:../avrx/serialio.S ****         push    R12
 345:../avrx/serialio.S ****         push    R13
 346               	
 347:../avrx/serialio.S ****         mov     R13, p1l
 348:../avrx/serialio.S ****         clr     R10
 349:../avrx/serialio.S ****         clr     R11
 350:../avrx/serialio.S ****         clr     R12
 351               	gh_00:
 352:../avrx/serialio.S ****         rcall   _GetChar
 353:../avrx/serialio.S ****         rcall   IsHex
 354:../avrx/serialio.S ****         brtc    gh_xx
 355:../avrx/serialio.S ****         cpi     r1l, '9'+1
 356:../avrx/serialio.S ****         brge    gh_01
 357:../avrx/serialio.S ****         subi    r1l, '0'
 358:../avrx/serialio.S ****         rjmp    gh_02
 359               	gh_01:
 360:../avrx/serialio.S ****         cbr     r1l, 0x20
 361:../avrx/serialio.S ****         subi    r1l, 'A'-10
 362               	gh_02:
 363:../avrx/serialio.S ****         lsl     R10
 364:../avrx/serialio.S ****         rol     R11
 365:../avrx/serialio.S ****         lsl     R10
 366:../avrx/serialio.S ****         rol     R11
 367:../avrx/serialio.S ****         lsl     R10
 368:../avrx/serialio.S ****         rol     R11
 369:../avrx/serialio.S ****         lsl     R10
 370:../avrx/serialio.S ****         rol     R11
 371:../avrx/serialio.S ****         add     R10, r1l
 372:../avrx/serialio.S ****         inc     R12
 373:../avrx/serialio.S ****         dec     R13
 374:../avrx/serialio.S ****         brne    gh_00
 375               	gh_xx:
 376:../avrx/serialio.S ****         mov     p2l, R12
 377:../avrx/serialio.S ****         mov     r1l, R10
 378:../avrx/serialio.S ****         mov     r1h, R11
 379               	
 380:../avrx/serialio.S ****         pop     R13
 381:../avrx/serialio.S ****         pop     R12
 382:../avrx/serialio.S ****         pop     R11
 383:../avrx/serialio.S ****         pop     R10
 384:../avrx/serialio.S ****         ret
 385               	        _ENDFUNC
 386               	
 387               	
 388               	;-----------------------------------------
 389               	; GetHexWord
 390               	;
 391               	        _FUNCTION(GetHexWord)
 392               	
 393               	GetHexWord:
 394:../avrx/serialio.S ****         ldi     p1l, 4
 395:../avrx/serialio.S ****         rjmp    _GetHex
 396               	        _ENDFUNC
 397               	;-----------------------------------------
 398               	; GetHexByte
 399               	;
 400               	        _FUNCTION(GetHexByte)
 401               	
 402               	GetHexByte:
 403:../avrx/serialio.S ****         ldi     p1l, 2
 404:../avrx/serialio.S ****         rjmp    _GetHex
 405               	        _ENDFUNC
 406               	;-----------------------------------------
 407               	; GetHexByte
 408               	;
 409               	        _FUNCTION(GetHexChar)
 410               	
 411               	GetHexChar:
 412:../avrx/serialio.S ****         ldi     p1l, 1
 413:../avrx/serialio.S ****         rjmp    _GetHex
 414               	        _ENDFUNC
 415               	;-----------------------------------------
 416               	; IsHex
 417               	;
 418               	; Tests RxByte for ascii hex char
 419               	; Returns: T bit
 420               	;
 421               	        _FUNCTION(IsHex)
 422               	
 423               	IsHex:
 424:../avrx/serialio.S ****         push    p1l
 425:../avrx/serialio.S ****         lds     p1l, _RxByte
 426:../avrx/serialio.S ****         clt
 427:../avrx/serialio.S ****         cpi     p1l, '0'
 428:../avrx/serialio.S ****         brlt    ihno
 429:../avrx/serialio.S ****         cpi     p1l, '9'+1
 430:../avrx/serialio.S ****         brlt    ihyes
 431:../avrx/serialio.S ****         cpi     p1l, 'A'
 432:../avrx/serialio.S ****         brlt    ihno
 433:../avrx/serialio.S ****         cpi     p1l, 'F'+1
 434:../avrx/serialio.S ****         brlt    ihyes
 435:../avrx/serialio.S ****         cpi     p1l, 'a'
 436:../avrx/serialio.S ****         brlt    ihno
 437:../avrx/serialio.S ****         cpi     p1l, 'f'+1
 438:../avrx/serialio.S ****         brge    ihno
 439               	ihyes:
 440:../avrx/serialio.S ****         set
 441               	ihno:
 442:../avrx/serialio.S ****         pop     p1l
 443:../avrx/serialio.S ****         ret
 444               	        _ENDFUNC
 445               	;-----------------------------------------
 446               	; IsWhite
 447               	;
 448               	; Tests RxByte for space or CR
 449               	; Returns: T bit
 450               	;
 451               	        _FUNCTION(IsWhite)
 452               	
 453               	IsWhite:
 454:../avrx/serialio.S ****         push    p1l
 455:../avrx/serialio.S ****         lds     p1l, _RxByte
 456:../avrx/serialio.S ****         clt
 457:../avrx/serialio.S ****         cpi     p1l, ' '
 458:../avrx/serialio.S ****         breq    ihyes
 459:../avrx/serialio.S ****         cpi     p1l, 0x0D
 460:../avrx/serialio.S ****         breq    ihyes
 461:../avrx/serialio.S ****         rjmp    ihno
 462               	        _ENDFUNC
 463               	;-----------------------------------------
 464               	; void _PutHex(unsigned val, char digits)
 465               	;
 466               	; Passed:       p2 = Value, p1l = # digits
 467               	; RETURN:       Nothing
 468               	; USES:         R25, TxByte
 469               	; STACK:        2
 470               	;
 471               	        _FUNCTION(_PutHex)
 472               	
 473               	_PutHex:
 474:../avrx/serialio.S ****         ldi     tmp2, 4          ; Maximum number of digits.
 475:../avrx/serialio.S ****         mov     tmp3, p2l
 476:../avrx/serialio.S ****         mov     p2l, p1l
 477:../avrx/serialio.S ****         mov     p2h, p1h
 478               	ph00:
 479:../avrx/serialio.S ****         lsl     p2l
 480:../avrx/serialio.S ****         rol     p2h
 481:../avrx/serialio.S ****         rol     p1l
 482:../avrx/serialio.S ****         lsl     p2l
 483:../avrx/serialio.S ****         rol     p2h
 484:../avrx/serialio.S ****         rol     p1l
 485:../avrx/serialio.S ****         lsl     p2l
 486:../avrx/serialio.S ****         rol     p2h
 487:../avrx/serialio.S ****         rol     p1l
 488:../avrx/serialio.S ****         lsl     p2l
 489:../avrx/serialio.S ****         rol     p2h
 490:../avrx/serialio.S ****         rol     p1l
 491               	
 492:../avrx/serialio.S ****         cp      tmp3, tmp2
 493:../avrx/serialio.S ****         brlt    ph02
 494               	
 495:../avrx/serialio.S ****         cbr     p1l, 0xF0
 496:../avrx/serialio.S ****         subi    p1l, lo8(-'0')          ; Addi 0
 497:../avrx/serialio.S ****         cpi     p1l, lo8('9' + 1)       ; if > 9
 498:../avrx/serialio.S ****         brlt    ph01                    ; subi 9 and add A
 499:../avrx/serialio.S ****         subi    p1l, lo8('9' + 1 - 'A')
 500               	ph01:
 501:../avrx/serialio.S ****         rcall   PutChar
 502               	ph02:
 503:../avrx/serialio.S ****         dec     tmp2
 504:../avrx/serialio.S ****         brne    ph00
 505               	
 506:../avrx/serialio.S ****         ret
 507               	        _ENDFUNC
 508               	;-----------------------------------------
 509               	; Put out a hex word
 510               	;
 511               	; Passed: Y = word
 512               	;
 513               	        _FUNCTION(PutHexWord)
 514               	
 515               	PutHexWord:
 516:../avrx/serialio.S ****         ldi     p2l, 4
 517:../avrx/serialio.S ****         rjmp    _PutHex
 518               	        _ENDFUNC
 519               	;-----------------------------------------
 520               	; Put out a two ascii hex byte
 521               	; Yl = byte
 522               	;
 523               	        _FUNCTION(PutHexByte)
 524               	
 525               	PutHexByte:
 526:../avrx/serialio.S ****         ldi     p2l, 2
 527:../avrx/serialio.S ****         rjmp    _PutHex
 528               	        _ENDFUNC
 529               	        _END
DEFINED SYMBOLS
                            *ABS*:00000000 ../avrx/serialio.S
C:\DOCUME~1\Mike\LOCALS~1\Temp/cccBaaaa.s:0      .text:00000000 L0F0
                            *COM*:00000001 SioFlags
                            *COM*:00000001 _RxByte
                            *COM*:00000002 RxC_Flag
                            *COM*:00000002 TxIntFlag
  ../avrx/serialio.S:128    .text.avrx.serialio:00000000 PushChar
  ../avrx/serialio.S:129    .text.avrx.serialio:00000000 L0F1
  ../avrx/serialio.S:129    .text.avrx.serialio:00000000 L0L0
  ../avrx/serialio.S:130    .text.avrx.serialio:00000000 L0L1
  ../avrx/serialio.S:131    .text.avrx.serialio:00000000 L0L2
  ../avrx/serialio.S:132    .text.avrx.serialio:00000000 L0L3
  ../avrx/serialio.S:133    .text.avrx.serialio:00000000 L0L4
  ../avrx/serialio.S:134    .text.avrx.serialio:00000000 L0L5
  ../avrx/serialio.S:135    .text.avrx.serialio:00000000 L0endfunc0
  ../avrx/serialio.S:149    .text.avrx.serialio:00000000 GetChar
  ../avrx/serialio.S:150    .text.avrx.serialio:00000000 L0L6
  ../avrx/serialio.S:151    .text.avrx.serialio:00000000 L0L7
  ../avrx/serialio.S:152    .text.avrx.serialio:00000000 L0L8
  ../avrx/serialio.S:157    .text.avrx.serialio:00000000 gc00
  ../avrx/serialio.S:153    .text.avrx.serialio:00000000 L0L9
  ../avrx/serialio.S:154    .text.avrx.serialio:00000000 L0L10
  ../avrx/serialio.S:161    .text.avrx.serialio:00000000 gc01
  ../avrx/serialio.S:155    .text.avrx.serialio:00000000 L0L11
  ../avrx/serialio.S:156    .text.avrx.serialio:00000000 L0L12
  ../avrx/serialio.S:158    .text.avrx.serialio:00000000 L0L13
  ../avrx/serialio.S:159    .text.avrx.serialio:00000000 L0L14
  ../avrx/serialio.S:160    .text.avrx.serialio:00000000 L0L15
  ../avrx/serialio.S:162    .text.avrx.serialio:00000000 L0L16
  ../avrx/serialio.S:163    .text.avrx.serialio:00000000 L0L17
  ../avrx/serialio.S:164    .text.avrx.serialio:00000000 L0endfunc1
  ../avrx/serialio.S:175    .text.avrx.serialio:00000000 _GetChar
  ../avrx/serialio.S:176    .text.avrx.serialio:00000000 L0L18
  ../avrx/serialio.S:177    .text.avrx.serialio:00000000 L0L19
  ../avrx/serialio.S:317    .text.avrx.serialio:00000000 PutChar
  ../avrx/serialio.S:178    .text.avrx.serialio:00000000 L0endfunc2
  ../avrx/serialio.S:187    .text.avrx.serialio:00000000 PutCR
  ../avrx/serialio.S:188    .text.avrx.serialio:00000000 L0L20
  ../avrx/serialio.S:189    .text.avrx.serialio:00000000 L0L21
  ../avrx/serialio.S:190    .text.avrx.serialio:00000000 L0endfunc3
  ../avrx/serialio.S:200    .text.avrx.serialio:00000000 PutSpace
  ../avrx/serialio.S:201    .text.avrx.serialio:00000000 L0L22
  ../avrx/serialio.S:202    .text.avrx.serialio:00000000 L0L23
  ../avrx/serialio.S:203    .text.avrx.serialio:00000000 L0endfunc4
  ../avrx/serialio.S:216    .text.avrx.serialio:00000000 _PrintString
  ../avrx/serialio.S:217    .text.avrx.serialio:00000000 L0L24
  ../avrx/serialio.S:218    .text.avrx.serialio:00000000 L0L25
  ../avrx/serialio.S:219    .text.avrx.serialio:00000000 _foo
  ../avrx/serialio.S:220    .text.avrx.serialio:00000000 L0L26
  ../avrx/serialio.S:221    .text.avrx.serialio:00000000 L0L27
  ../avrx/serialio.S:222    .text.avrx.serialio:00000000 L0L28
  ../avrx/serialio.S:231    .text.avrx.serialio:00000000 _ps00
  ../avrx/serialio.S:223    .text.avrx.serialio:00000000 L0L29
  ../avrx/serialio.S:224    .text.avrx.serialio:00000000 L0L30
  ../avrx/serialio.S:225    .text.avrx.serialio:00000000 L0L31
  ../avrx/serialio.S:226    .text.avrx.serialio:00000000 L0L32
  ../avrx/serialio.S:227    .text.avrx.serialio:00000000 L0L33
  ../avrx/serialio.S:228    .text.avrx.serialio:00000000 L0L34
  ../avrx/serialio.S:229    .text.avrx.serialio:00000000 L0L35
  ../avrx/serialio.S:230    .text.avrx.serialio:00000000 L0L36
  ../avrx/serialio.S:232    .text.avrx.serialio:00000000 L0L37
  ../avrx/serialio.S:233    .text.avrx.serialio:00000000 L0L38
  ../avrx/serialio.S:234    .text.avrx.serialio:00000000 L0L39
  ../avrx/serialio.S:235    .text.avrx.serialio:00000000 L0endfunc5
  ../avrx/serialio.S:247    .text.avrx.serialio:00000000 InitSerialIO
  ../avrx/serialio.S:248    .text.avrx.serialio:00000000 L0L40
  ../avrx/serialio.S:250    .text.avrx.serialio:00000000 L0L41
  ../avrx/serialio.S:253    .text.avrx.serialio:00000000 L0L42
  ../avrx/serialio.S:254    .text.avrx.serialio:00000000 L0L43
  ../avrx/serialio.S:256    .text.avrx.serialio:00000000 L0L44
  ../avrx/serialio.S:257    .text.avrx.serialio:00000000 L0L45
  ../avrx/serialio.S:258    .text.avrx.serialio:00000000 L0L46
  ../avrx/serialio.S:259    .text.avrx.serialio:00000000 L0endfunc6
  ../avrx/serialio.S:268    .text.avrx.serialio:00000000 SIG_UART_DATA
  ../avrx/serialio.S:269    .text.avrx.serialio:00000000 L0L47
  ../avrx/serialio.S:271    .text.avrx.serialio:00000000 L0L48
  ../avrx/serialio.S:273    .text.avrx.serialio:00000000 L0L49
  ../avrx/serialio.S:274    .text.avrx.serialio:00000000 L0L50
  ../avrx/serialio.S:275    .text.avrx.serialio:00000000 L0L51
  ../avrx/serialio.S:277    .text.avrx.serialio:00000000 L0L52
  ../avrx/serialio.S:278    .text.avrx.serialio:00000000 L0endfunc7
  ../avrx/serialio.S:287    .text.avrx.serialio:00000000 SIG_UART_RECV
  ../avrx/serialio.S:288    .text.avrx.serialio:00000000 L0L53
  ../avrx/serialio.S:290    .text.avrx.serialio:00000000 L0L54
  ../avrx/serialio.S:292    .text.avrx.serialio:00000000 L0L55
  ../avrx/serialio.S:293    .text.avrx.serialio:00000000 L0L56
  ../avrx/serialio.S:295    .text.avrx.serialio:00000000 L0L57
  ../avrx/serialio.S:296    .text.avrx.serialio:00000000 L0L58
  ../avrx/serialio.S:297    .text.avrx.serialio:00000000 L0L59
  ../avrx/serialio.S:299    .text.avrx.serialio:00000000 L0L60
  ../avrx/serialio.S:300    .text.avrx.serialio:00000000 L0L61
  ../avrx/serialio.S:301    .text.avrx.serialio:00000000 L0endfunc8
  ../avrx/serialio.S:318    .text.avrx.serialio:00000000 L0L62
  ../avrx/serialio.S:319    .text.avrx.serialio:00000000 L0L63
  ../avrx/serialio.S:327    .text.avrx.serialio:00000000 pc00
  ../avrx/serialio.S:321    .text.avrx.serialio:00000000 L0L64
  ../avrx/serialio.S:322    .text.avrx.serialio:00000000 L0L65
  ../avrx/serialio.S:323    .text.avrx.serialio:00000000 L0L66
  ../avrx/serialio.S:324    .text.avrx.serialio:00000000 L0L67
  ../avrx/serialio.S:325    .text.avrx.serialio:00000000 L0L68
  ../avrx/serialio.S:326    .text.avrx.serialio:00000000 L0L69
  ../avrx/serialio.S:328    .text.avrx.serialio:00000000 L0L70
  ../avrx/serialio.S:329    .text.avrx.serialio:00000000 L0L71
  ../avrx/serialio.S:330    .text.avrx.serialio:00000000 L0endfunc9
  ../avrx/serialio.S:341    .text.avrx.serialio:00000000 _GetHex
  ../avrx/serialio.S:342    .text.avrx.serialio:00000000 L0L72
  ../avrx/serialio.S:343    .text.avrx.serialio:00000000 L0L73
  ../avrx/serialio.S:344    .text.avrx.serialio:00000000 L0L74
  ../avrx/serialio.S:345    .text.avrx.serialio:00000000 L0L75
  ../avrx/serialio.S:347    .text.avrx.serialio:00000000 L0L76
  ../avrx/serialio.S:348    .text.avrx.serialio:00000000 L0L77
  ../avrx/serialio.S:349    .text.avrx.serialio:00000000 L0L78
  ../avrx/serialio.S:350    .text.avrx.serialio:00000000 L0L79
  ../avrx/serialio.S:351    .text.avrx.serialio:00000000 gh_00
  ../avrx/serialio.S:352    .text.avrx.serialio:00000000 L0L80
  ../avrx/serialio.S:353    .text.avrx.serialio:00000000 L0L81
  ../avrx/serialio.S:423    .text.avrx.serialio:00000000 IsHex
  ../avrx/serialio.S:354    .text.avrx.serialio:00000000 L0L82
  ../avrx/serialio.S:375    .text.avrx.serialio:00000000 gh_xx
  ../avrx/serialio.S:355    .text.avrx.serialio:00000000 L0L83
  ../avrx/serialio.S:356    .text.avrx.serialio:00000000 L0L84
  ../avrx/serialio.S:359    .text.avrx.serialio:00000000 gh_01
  ../avrx/serialio.S:357    .text.avrx.serialio:00000000 L0L85
  ../avrx/serialio.S:358    .text.avrx.serialio:00000000 L0L86
  ../avrx/serialio.S:362    .text.avrx.serialio:00000000 gh_02
  ../avrx/serialio.S:360    .text.avrx.serialio:00000000 L0L87
  ../avrx/serialio.S:361    .text.avrx.serialio:00000000 L0L88
  ../avrx/serialio.S:363    .text.avrx.serialio:00000000 L0L89
  ../avrx/serialio.S:364    .text.avrx.serialio:00000000 L0L90
  ../avrx/serialio.S:365    .text.avrx.serialio:00000000 L0L91
  ../avrx/serialio.S:366    .text.avrx.serialio:00000000 L0L92
  ../avrx/serialio.S:367    .text.avrx.serialio:00000000 L0L93
  ../avrx/serialio.S:368    .text.avrx.serialio:00000000 L0L94
  ../avrx/serialio.S:369    .text.avrx.serialio:00000000 L0L95
  ../avrx/serialio.S:370    .text.avrx.serialio:00000000 L0L96
  ../avrx/serialio.S:371    .text.avrx.serialio:00000000 L0L97
  ../avrx/serialio.S:372    .text.avrx.serialio:00000000 L0L98
  ../avrx/serialio.S:373    .text.avrx.serialio:00000000 L0L99
  ../avrx/serialio.S:374    .text.avrx.serialio:00000000 L0L100
  ../avrx/serialio.S:376    .text.avrx.serialio:00000000 L0L101
  ../avrx/serialio.S:377    .text.avrx.serialio:00000000 L0L102
  ../avrx/serialio.S:378    .text.avrx.serialio:00000000 L0L103
  ../avrx/serialio.S:380    .text.avrx.serialio:00000000 L0L104
  ../avrx/serialio.S:381    .text.avrx.serialio:00000000 L0L105
  ../avrx/serialio.S:382    .text.avrx.serialio:00000000 L0L106
  ../avrx/serialio.S:383    .text.avrx.serialio:00000000 L0L107
  ../avrx/serialio.S:384    .text.avrx.serialio:00000000 L0L108
  ../avrx/serialio.S:385    .text.avrx.serialio:00000000 L0endfunc10
  ../avrx/serialio.S:393    .text.avrx.serialio:00000000 GetHexWord
  ../avrx/serialio.S:394    .text.avrx.serialio:00000000 L0L109
  ../avrx/serialio.S:395    .text.avrx.serialio:00000000 L0L110
  ../avrx/serialio.S:396    .text.avrx.serialio:00000000 L0endfunc11
  ../avrx/serialio.S:402    .text.avrx.serialio:00000000 GetHexByte
  ../avrx/serialio.S:403    .text.avrx.serialio:00000000 L0L111
  ../avrx/serialio.S:404    .text.avrx.serialio:00000000 L0L112
  ../avrx/serialio.S:405    .text.avrx.serialio:00000000 L0endfunc12
  ../avrx/serialio.S:411    .text.avrx.serialio:00000000 GetHexChar
  ../avrx/serialio.S:412    .text.avrx.serialio:00000000 L0L113
  ../avrx/serialio.S:413    .text.avrx.serialio:00000000 L0L114
  ../avrx/serialio.S:414    .text.avrx.serialio:00000000 L0endfunc13
  ../avrx/serialio.S:424    .text.avrx.serialio:00000000 L0L115
  ../avrx/serialio.S:425    .text.avrx.serialio:00000000 L0L116
  ../avrx/serialio.S:426    .text.avrx.serialio:00000000 L0L117
  ../avrx/serialio.S:427    .text.avrx.serialio:00000000 L0L118
  ../avrx/serialio.S:428    .text.avrx.serialio:00000000 L0L119
  ../avrx/serialio.S:441    .text.avrx.serialio:00000000 ihno
  ../avrx/serialio.S:429    .text.avrx.serialio:00000000 L0L120
  ../avrx/serialio.S:430    .text.avrx.serialio:00000000 L0L121
  ../avrx/serialio.S:439    .text.avrx.serialio:00000000 ihyes
  ../avrx/serialio.S:431    .text.avrx.serialio:00000000 L0L122
  ../avrx/serialio.S:432    .text.avrx.serialio:00000000 L0L123
  ../avrx/serialio.S:433    .text.avrx.serialio:00000000 L0L124
  ../avrx/serialio.S:434    .text.avrx.serialio:00000000 L0L125
  ../avrx/serialio.S:435    .text.avrx.serialio:00000000 L0L126
  ../avrx/serialio.S:436    .text.avrx.serialio:00000000 L0L127
  ../avrx/serialio.S:437    .text.avrx.serialio:00000000 L0L128
  ../avrx/serialio.S:438    .text.avrx.serialio:00000000 L0L129
  ../avrx/serialio.S:440    .text.avrx.serialio:00000000 L0L130
  ../avrx/serialio.S:442    .text.avrx.serialio:00000000 L0L131
  ../avrx/serialio.S:443    .text.avrx.serialio:00000000 L0L132
  ../avrx/serialio.S:444    .text.avrx.serialio:00000000 L0endfunc14
  ../avrx/serialio.S:453    .text.avrx.serialio:00000000 IsWhite
  ../avrx/serialio.S:454    .text.avrx.serialio:00000000 L0L133
  ../avrx/serialio.S:455    .text.avrx.serialio:00000000 L0L134
  ../avrx/serialio.S:456    .text.avrx.serialio:00000000 L0L135
  ../avrx/serialio.S:457    .text.avrx.serialio:00000000 L0L136
  ../avrx/serialio.S:458    .text.avrx.serialio:00000000 L0L137
  ../avrx/serialio.S:459    .text.avrx.serialio:00000000 L0L138
  ../avrx/serialio.S:460    .text.avrx.serialio:00000000 L0L139
  ../avrx/serialio.S:461    .text.avrx.serialio:00000000 L0L140
  ../avrx/serialio.S:462    .text.avrx.serialio:00000000 L0endfunc15
  ../avrx/serialio.S:473    .text.avrx.serialio:00000000 _PutHex
  ../avrx/serialio.S:474    .text.avrx.serialio:00000000 L0L141
  ../avrx/serialio.S:475    .text.avrx.serialio:00000000 L0L142
  ../avrx/serialio.S:476    .text.avrx.serialio:00000000 L0L143
  ../avrx/serialio.S:477    .text.avrx.serialio:00000000 L0L144
  ../avrx/serialio.S:478    .text.avrx.serialio:00000000 ph00
  ../avrx/serialio.S:479    .text.avrx.serialio:00000000 L0L145
  ../avrx/serialio.S:480    .text.avrx.serialio:00000000 L0L146
  ../avrx/serialio.S:481    .text.avrx.serialio:00000000 L0L147
  ../avrx/serialio.S:482    .text.avrx.serialio:00000000 L0L148
  ../avrx/serialio.S:483    .text.avrx.serialio:00000000 L0L149
  ../avrx/serialio.S:484    .text.avrx.serialio:00000000 L0L150
  ../avrx/serialio.S:485    .text.avrx.serialio:00000000 L0L151
  ../avrx/serialio.S:486    .text.avrx.serialio:00000000 L0L152
  ../avrx/serialio.S:487    .text.avrx.serialio:00000000 L0L153
  ../avrx/serialio.S:488    .text.avrx.serialio:00000000 L0L154
  ../avrx/serialio.S:489    .text.avrx.serialio:00000000 L0L155
  ../avrx/serialio.S:490    .text.avrx.serialio:00000000 L0L156
  ../avrx/serialio.S:492    .text.avrx.serialio:00000000 L0L157
  ../avrx/serialio.S:493    .text.avrx.serialio:00000000 L0L158
  ../avrx/serialio.S:502    .text.avrx.serialio:00000000 ph02
  ../avrx/serialio.S:495    .text.avrx.serialio:00000000 L0L159
  ../avrx/serialio.S:496    .text.avrx.serialio:00000000 L0L160
  ../avrx/serialio.S:497    .text.avrx.serialio:00000000 L0L161
  ../avrx/serialio.S:498    .text.avrx.serialio:00000000 L0L162
  ../avrx/serialio.S:500    .text.avrx.serialio:00000000 ph01
  ../avrx/serialio.S:499    .text.avrx.serialio:00000000 L0L163
  ../avrx/serialio.S:501    .text.avrx.serialio:00000000 L0L164
  ../avrx/serialio.S:503    .text.avrx.serialio:00000000 L0L165
  ../avrx/serialio.S:504    .text.avrx.serialio:00000000 L0L166
  ../avrx/serialio.S:506    .text.avrx.serialio:00000000 L0L167
  ../avrx/serialio.S:507    .text.avrx.serialio:00000000 L0endfunc16
  ../avrx/serialio.S:515    .text.avrx.serialio:00000000 PutHexWord
  ../avrx/serialio.S:516    .text.avrx.serialio:00000000 L0L168
  ../avrx/serialio.S:517    .text.avrx.serialio:00000000 L0L169
  ../avrx/serialio.S:518    .text.avrx.serialio:00000000 L0endfunc17
  ../avrx/serialio.S:525    .text.avrx.serialio:00000000 PutHexByte
  ../avrx/serialio.S:526    .text.avrx.serialio:00000000 L0L170
  ../avrx/serialio.S:527    .text.avrx.serialio:00000000 L0L171
  ../avrx/serialio.S:528    .text.avrx.serialio:00000000 L0endfunc18

UNDEFINED SYMBOLS
AvrXWaitSemaphore
UCSZ1
UCSZ0
TXEN
RXEN
RXCIE
UCR0
UDRIE
IntProlog
AvrXIntSetSemaphore
_Epilog
UDRE
